#!/usr/bin/ruby

NB_COLUMNS = 8
NB_PLAYERS = 2
MOVELIST_COLUMN = 27  # i.e. 28th field

def first_player(move_number)
  move_number == '1w'
end

def print_setup(move_number, square2piece, setup_to_mirror)
  if setup_to_mirror
    mirror_board(square2piece)
  end

  printf '%s %s', move_number,
         square2piece.sort_by { |square, piece| square.reverse }\
                     .collect { |row, piece| piece }\
                     .each_slice(NB_COLUMNS)\
                     .collect { |row| row.join }.join('/')
  if first_player(move_number)
    print '  '
  else
    print "\n"
  end
end

def mirror_board(square2piece)
  res = {}  # square => piece
  square2piece.each do |square, piece|
    res[mirror_square(square)] = piece
  end
  square2piece.replace(res)
end

def mirror_square(square)
  square.sub(/^./) { |column| mirror_column(column) }
end

def mirror_column(column)
  (2 * 'a'.ord + NB_COLUMNS - column.ord - 1).chr  # i.e. a => h, b => g, etc.
end

STDIN.each_with_index do |line, index|
  next if index == 0  # header

  setup_to_mirror = false

  board_setup = line.split("\t")[MOVELIST_COLUMN].split("\\n").first(NB_PLAYERS)
  board_setup.each do |player_setup|
    move_number, placement = player_setup.split(' ', 2)

    square2piece = {}
    placement.split.each do |word|
      piece = word[0].upcase
      square = word[1..2]

      if first_player(move_number) and piece == 'E' and square =~ /^[a-d]/
        setup_to_mirror = true
      end

      square2piece[square] = piece
    end

    print_setup(move_number, square2piece, setup_to_mirror)
  end
end
